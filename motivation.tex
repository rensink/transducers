\section{Motivation}
\label{sec:motivation}

In this paper, we assume that we are given a labelled transition system (LTS), for instance generated by a set of rules that have been applied iteratively to a start object, in all possible ways. The general structure of an LTS is fixed as follows.

\begin{definition}[LTS]\label{defL;ts}
A \emph{Labelled Transition System} (LTS) is a tuple $\cS=\tupof{Q, L, {\trans{}}, {\final}, \qinit}$ in which
\begin{itemize}
\item $Q$ is a set of states;
\item $L$ is a set of labels;
\item ${\trans{}}\subseteq Q\times\L\times Q$ is a transition relation;
\item ${\final}\subseteq Q$ is a termination predicate;
\item $\qinit\in Q$ is the initial state.
\end{itemize}
\end{definition}
%
We will make sure that all our constructions are well-defined up to \emph{bisimilarity} of LTSs.
%
\begin{definition}[bisimilarity]\label{def:bisimilarity}
Let $Q$ be a set of states and ${\trans{}}\subseteq Q\times L\times Q$ a transition relation. Two states $q_1,q_2\in Q$ are called \emph{bisimilar} if $q_1\simeq q_2$, where ${\simeq}\subseteq Q\times Q$ is the largest symmetric relation such that
\begin{inumerate}
\item $q_1\simeq q_2\trans a q_2'$ (for arbitrary $q_1,q_2,q_2'\in Q$) implies that there is some $q_1'\in Q$ such that $q_1\trans a q_1'\simeq q_2'$;
\item $q_1\simeq q_2\final$ (for arbitrary $q_1,q_2\in Q$) implies $q_1\final$.
\end{inumerate}

Two labelled transition systems $\cS_1,\cS_2$ with disjoint state sets are called bisimilar, denoted $\cS_1\simeq \cS_2$, if $\qinit_1\simeq \qinit_2$ in $Q=Q_1\cup Q_2$ with transition relation ${\trans{}}={\rightarrow_1}\cup {\rightarrow_2}$ and termination predicate ${\final}={\final_1}\cup {\final_2}$.
\end{definition}
%
We now introduce a notion of \emph{control} over transition systems that restricts the allowed behaviour. This is achieved by \emph{imposing} a so-called \emph{control automaton} on a transition system. In its simplest form, a control automaton is itself just a transition system, and imposition is exactly (TCS) synchronisation, as encoded in the following rule (where $c,c'$ are states of the control automaton):
%
\begin{center}
\AxiomC{$c\trans a c'$}
\AxiomC{$q \trans a q'$}
\BinaryInfC{$c\on q\trans a c'\on q'$}
\DisplayProof
%
\quad
%
\AxiomC{$c\final$}
\AxiomC{$q\final$}
\BinaryInfC{$c\on q \:\final$}
\DisplayProof
\end{center}
%
Clearly, this gives rise to another transition system (and clearly, imposition is well-defined modulo bisimilarity). We think of control transitions as \emph{enabling} an action, and system transitions as \emph{applying} them. The similarity between their formalisations will disappear as soon as we introduce more control constructs.

In practice, control involves more than just restricting the allowed transitions. A feature that is found in all control languages is \emph{conditional execution}. Essentially, this means that an action is enabled only \emph{after} some other possibilities have been tried \emph{and failed because they were not applicable}. In process algebra, this construction has been studied under the name \emph{priority choice} \cite{CCS-with-priority-choice}. It involves the following extensions to the formalism:
%
\begin{itemize}
\item An auxiliary (derived) predicate ${\cando}\subseteq Q\times\powersetof{L}$ over system automata, defined by $q\cando X\iffdef \exists a\in X\st q\trans a$. In words, $q\cando X$ signifies that at least one of the actions in $X$ is applicable in $q$.

%\item An additional predicate ${\tries} \subseteq C\times \powersetof{L}$ for control automata, where $c\tries X$ signifies that $c$ enables precisely the actions in $X$;

\item Extended control labels $a\ifnot X$ (read ``$a$ unless $X$'') for $a\in L$ and $X\subseteq L$, signifying that $a$ is enabled if and only none of the actions in $X$ is applicable.
\end{itemize}
%
The rule for action execution in a controlled system then becomes:
%
\begin{center}
\AxiomC{$c\trans{a\ifnot X} c'$}
\AxiomC{$q\ncando X$}
\AxiomC{$q\trans a q'$}
\TrinaryInfC{$c\on q \trans a c'\on q'$}
\DisplayProof
\end{center}

