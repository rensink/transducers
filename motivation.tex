\section{Motivation}
\label{sec:motivation}

We assume that we start with a model of system behaviour in the form of a \emph{system automaton}, for instance generated by a set of rules that have been applied iteratively to a start object in all possible ways. System automata are given as labelled transition systems.

\begin{definition}[LTS]\label{defL;ts}
A \emph{Labelled Transition System} (LTS) is a tuple $\cS=\tupof{Q, L, {\trans{}}, {\final}, \qinit}$ in which
\begin{itemize}
\item $Q$ is a set of states;
\item $L$ is a set of labels, also called the \emph{alphabet} of $\cS$;
\item ${\trans{}}\subseteq Q\times\L\times Q$ is a transition relation;
\item ${\final}\subseteq Q$ is a termination predicate, identifying the subset of final states;
\item $\qinit\in Q$ is the initial state.
\end{itemize}
\end{definition}
%
As usual, we write $q\trans a q'$ for $(q,a,q')\in {\trans{}}$, $q\trans{} q'$ for $\exists a\st q\trans a q'$, etc.; we also write $q\final$ for $q\in{\final}$. The set of system automata with alphabet $L$ is denoted $\SA_L$.
\begin{comment}
We will make sure that all our constructions are well-defined up to \emph{bisimilarity} of LTSs.
%
\begin{definition}[bisimilarity]\label{def:bisimilarity}
Let $Q$ be a set of states and ${\trans{}}\subseteq Q\times L\times Q$ a transition relation. Two states $q_1,q_2\in Q$ are called \emph{bisimilar} if $q_1\simeq q_2$, where ${\simeq}\subseteq Q\times Q$ is the largest symmetric relation such that
\begin{inumerate}
\item $q_1\simeq q_2\trans a q_2'$ (for arbitrary $q_1,q_2,q_2'\in Q$) implies that there is some $q_1'\in Q$ such that $q_1\trans a q_1'\simeq q_2'$;
\item $q_1\simeq q_2\final$ (for arbitrary $q_1,q_2\in Q$) implies $q_1\final$.
\end{inumerate}

Two labelled transition systems $\cS_1,\cS_2$ with disjoint state sets are called bisimilar, denoted $\cS_1\simeq \cS_2$, if $\qinit_1\simeq \qinit_2$ in $Q=Q_1\cup Q_2$ with transition relation ${\trans{}}={\rightarrow_1}\cup {\rightarrow_2}$ and termination predicate ${\final}={\final_1}\cup {\final_2}$.
\end{definition}
\end{comment}

We restrict the possible behaviour of a system automaton $\cS$ by \emph{imposing} a so-called \emph{control automaton} $\cC$ on it, denoted $\cC\on \cS$, giving rise to another system automaton. We use $\CA_L$ to denote the set of control automata with alphabet $L$; the formal definition will follow. For now, we can think of a control automaton again as a transition system; imposition is exactly full (TCS-style) synchronisation, as encoded by the following rules (where $c,c'$ are states of the control automaton in $\CA_L$ and $q,q'$ states of a system automaton $\SA_L$, for some common set of labels $L$):
%
\begin{center}
\AxiomC{$c\trans a c'$}
\AxiomC{$q \trans a q'$}
\BinaryInfC{$c\on q\trans a c'\on q'$}
\DisplayProof
%
\quad
%
\AxiomC{$c\final$}
\AxiomC{$q\final$}
\BinaryInfC{$c\on q \:\final$}
\DisplayProof
\end{center}
%
We think of control transitions as \emph{enabling} or \emph{calling} its action, and system transitions as \emph{applying} or \emph{executing} it.

\paragraph{Conditional choice.}

A feature that is found in essentially all control languages is \emph{conditional choice}: there are multiple potential next actions from a given state, but some are only enabled after others have been tried and found inapplicable. We present a formalisation inspired by \emph{priority choice} \cite{CCS-with-priority-choice}.\footnote{The relation is discussed in more detail in \Cref{sec:disussion}.}
%
\begin{comment} It involves the following extensions to the formalism:
%
\begin{itemize}
\item An auxiliary (derived) predicate ${\cando}\subseteq Q\times\powersetof{L}$ over system automata, defined by $q\cando X\iffdef \exists a\in X\st q\trans a$. In words, $q\cando X$ signifies that at least one of the actions in $X$ is applicable in $q$.

%\item An additional predicate ${\tries} \subseteq C\times \powersetof{L}$ for control automata, where $c\tries X$ signifies that $c$ enables precisely the actions in $X$;

\item Extended control labels $a\ifnot X$ (read ``$a$ unless $X$'') for $a\in L$ and $X\subseteq L$, signifying that $a$ is enabled if and only none of the actions in $X$ is applicable.
\end{itemize}
%
The rule for action execution in a controlled system then becomes:
%
\begin{center}
\AxiomC{$c\trans{a\ifnot X} c'$}
\AxiomC{$q\ncando X$}
\AxiomC{$q\trans a q'$}
\TrinaryInfC{$c\on q \trans a c'\on q'$}
\DisplayProof
\end{center}
\end{comment}
%
We extend control automata with a binary relation $\movesto$ over (control) states, with the intuition that $c\movesto c'$ is activated only if none of the actions called in $c$ are executable in the current state of the system automaton. This is captured by the following rules:
%
\begin{center}
\def\defaultHypSeparation{\hskip2mm}
\AxiomC{$c\on q\not\to$}
\AxiomC{$c\movesto c'$}
\AxiomC{$c'\on q\trans a c''\on q'$}
\TrinaryInfC{$c\on q \trans a c''\on q'$}
\DisplayProof
%
\quad
%
\AxiomC{$c\on q\not\to$}
\AxiomC{$c\movesto c'$}
\AxiomC{$c'\on q\:\final$}
\TrinaryInfC{$c\on q\:\final$}
\DisplayProof
\end{center}

\paragraph{Action declaration.}

The second control feature we study is the ability to \emph{declare} new (abstract) actions as (concrete) control automata. The intuition behind this is that of procedural abstraction in programming languages: the execution of the abstract action comes down to the execution of its defining control automaton. In addition, we maintain the atomic nature of actions in our framework, meaning that we only consider the action to be executed if its defining control automaton can be applied up until a final state; a partial execution is equated to no execution at all. In other words, declared actions have transactional semantics.

In the process algebra literature, this closely corresponds to the concept of \emph{action refinement} (see \cite{Handbook-Action-Refinement} for an overview), with the difference that we are motivated by the capability to abstract, rather than refine. We will discuss the connection more closely in \Cref{sec:related}.

The declaration is captured by a function $\cD:A\to \CA_C$, mapping abstract actions $A$ to control automata over concrete actions $C$. We denote $A_\cD=A$ and $C_\cD=C$ for the abstract and concrete alphabets of $\cD$. The intended semantics is defined by abstracting a system automaton $\cS\in \SA_C$ into $\cS\abs \cD\in \SA_A$ with state set $\gensetof{q\abs \cD}{q\in Q_\cS}$ and initial state $\qinit_\cS\abs \cD$, as follows:
\begin{comment}
\begin{center}
\AxiomC{$c\final$}
\UnaryInfC{$c\on q\:\present\vphantom\abs$}
\DisplayProof
%
\quad
%
\AxiomC{$c\on q\trans a c'\on q'$}
\AxiomC{$c'\on q' \: \present$}
\BinaryInfC{$c\on q \: \present\vphantom\final$}
\DisplayProof
%
\quad
%
\AxiomC{$\smash{\qinit_{\cD(a)}}\on q \trans{a} c'\on q'$}
\AxiomC{$c'\on q' \: \present$}
\BinaryInfC{$q\abs \cD \trans a q'\abs \cD$}
\DisplayProof
\end{center}
\end{comment}
\begin{center}
\AxiomC{$\qinit_{\cD(a)}\on q \trans{}^+ c'\on q'$}
\AxiomC{$c'\final$}
\BinaryInfC{$q\abs \cD \trans a q'\abs \cD$}
\DisplayProof
%
\qquad
%
\AxiomC{$q\final\vphantom{\qinit_{\cD(a)}}$}
\UnaryInfC{$q\abs \cD \:\final\vphantom{q'\trans a}$}
\DisplayProof
\end{center}

\paragraph{Example.}

As running example, we define our own variation on a coffee machine. The concrete system automaton consists of two separate units: a \emph{pay unit} $P$ that accepts euro coins (denominations 1 or 2) and a \emph{dispenser unit} $B$ that dispenses coffee beans. $P$ defines actions $\eone$ and $\etwo$ for inserting 1- respectively 2-euro coins; the inserted money can be used to pay for coffee using $\emin$-actions. This pay unit has some quirks: at most two successive $\eone$s are accepted, and at most four euro can be stored at any point in time. $D$ gives out coffee beans using action $\beans$, but has to be refilled on a regular basis with action $\refill$ --- in fact, to keep the example at manageable size, we assume it has to be refilled after dispensing only a single batch of beans. We show the system automata for these two components separately; the combined behaviour is their (interleaving) parallel composition $P\times D$, with state set $\setof{0,1,2,2',3,4}\times \setof{f,e}$.

\begin{center}
\begin{tikzpicture}[baseline=(i.center),on grid]
\node (i) {};
\node (0) [below=0.7 of i] {$0$};
\node (1) [below left=of 0] {$1$};
\node (2) [below=of 1] {$2$};
\node (2') [below right=of 0] {$2'$};
\node (3) [below=of 2'] {$3$};
\node (4) [below=of 3] {$4$};

\path
  (i) edge[->] node[left=1.5] {$P:$} (0)
  (0) edge[->,bend right] node[left] {$\eone$} (1)
  (0) edge[->,bend left] node[right] {$\etwo$} (2')
  (1) edge[->] node[right] {$\emin$} (0)
  (1) edge[->,bend right] node[left] {$\eone$} (2)
  (1) edge[->] node[below] {$\etwo$} (3)
  (2) edge[->] node[right] {$\emin$} (1)
  (2) edge[->] node[below] {$\etwo$} (4)
  (2') edge[->] node[near start,above] {$\emin$} (1)
  (2') edge[->,bend left] node[right] {$\eone$} (3)
  (3) edge[->] node[left] {$\emin$} (2')
  (3) edge[->,bend left] node[right] {$\eone$} (4)
  (4) edge[->] node[left] {$\emin$} (3);
\end{tikzpicture}
\qquad
\begin{tikzpicture}[baseline=(i.center),on grid]
\node (i) {};
\node (f) [below=0.7 of i] {$f$};
\node (e) [below=1.5 of f] {$e$};

\path
  (i) edge[->] node[left=1] {$D:$} (f)
  (f) edge[->,bend right] node[left] {$\beans$} (e)
  (e) edge[->,bend right] node[right] {$\refill$} (f);
\end{tikzpicture}
\end{center}

We abstract this system automaton by declaring the following actions (using the calculus for control we formally introduce below):
%
\begin{align*}
\money & \mapsto \eone;(\eone\orelse \etwo) \orelse \etwo \\
\coffee & \mapsto \emin;(\beans;\emin \orelse \refill;\beans) 
\end{align*}
%
$\money$ models the insertion of coins: the user tries to insert two 1-euro coins, but if the pay unit doesn't either those, they insert a 2-euro coin instead. (The operator $\orelse$, read as ``or else'', introduced formally below, models conditional choice: the left operand is enabled, but if none of its initial actions is applicable then the right operand is enabled instead.) $\coffee$ models obtaining a coffee: the cost is 2 euro, but if the machine is out of beans (note the occurrence of another $\orelse$) then instead the user has to refill it, paying one euro less to reward them for that service.

In fact, we define two declarations: $\cD_1$ with $A_{\cD_1}=\setof{\money,\emin}$ and $C_{\cD_1}= L_P$, consisting of the mapping for $\money$ above and the identity $\emin\mapsto \emin$, and $\cD_2$ with $A_{\cD_2}=\setof{\money,\coffee}$ and $C_{\cD_2}=L_P\cup L_D$, consisting of the mappings for $\money$ and $\coffee$ above. This gives us two cases of abstraction:

\begin{center}
\begin{tikzpicture}[on grid,baseline=(i.center)]
\node (i) {};
\node (0) [below=0.7 of i] {$0$};
\node (1) [below left=of 0] {$1$};
\node (2) [below=of 1] {$2$};
\node (2') [below right=of 0] {$2'$};
\node (3) [below=of 2'] {$3$};
\node (4) [below=of 3] {$4$};

\path (i) edge[->] node[left=1] {$P\abs \cD_1:$} (0)
      (0) edge[->,bend right=60] node[left] {$\money$} (2)
      (1) edge[->] node[right] {$\emin$} (0)
      (1) edge[->] node[near start,right] {$\money$} (4)
      (2') edge[->] node[near start,above] {$\emin$} (1)
      (2') edge[->,bend left] node[right] {$\money$} (4)
      (2) edge[->] node[below] {$\money$} (4)
      (2) edge[->] node[right] {$\emin$} (1)
      (3) edge[->] node[left] {$\emin$} (2')
      (4) edge[->] node[left] {$\emin$} (3);
\end{tikzpicture}
\qquad
\begin{tikzpicture}[on grid,baseline=(i.center)]
\node (i) {};
\node (0f) [below=0.7 of i] {$0f$};
\node (2f) [below=1 of 0f] {$2f$};
\node (4f) [below=2 of 2f] {$4f$};
\node (0e) [left=3 of 0f] {$0e$};
\node (1e) [below left=of 0e] {$1e$};
\node (2e) [below=of 1e] {$2e$};
\node (2'e) [below right=1 and 1 of 0e] {$2'e$};
\node (3e) [below=of 2'e] {$3e$};
\node (4e) [below=of 3e] {$4e$};

\path (i) edge[->] node[left=3] {$(P\times D)\abs \cD_2:$} (0)
      (0f) edge[->] node[right] {$\money$} (2f) 
      (2f) edge[->] node[right] {$\money$} (4f)
           edge[->] node[above] {$\coffee$} (0e)
      (4f) edge[->] node[near start,above] {$\coffee$} (2'e)
      (0e) edge[->,bend right=60] node[left] {$\money$} (2e)
      (1e) edge[->] node[right] {$\coffee$} (0e)
           edge[->] node[near start,right] {$\money$} (4e)
      (2'e) edge[->] node[near start,above] {$\coffee$} (1e)
            edge[->,bend left] node[near end,right] {$\money$} (4e)
      (2e) edge[->] node[below] {$\money$} (4e)
           edge[->] node[right] {$\coffee$} (1e)
      (3e) edge[->] node[left] {$\coffee$} (2'e)
      (4e) edge[->] node[left] {$\coffee$} (3e);
\end{tikzpicture}
\end{center}
%
We observe the following abstraction effects in $P\abs \cD_1$:
%
\begin{itemize}
\item From states 0 and $2'$, the abstract $\money$-action consists of two successive concrete $\eone$-executions, whereas from state $2$, where $\eone$ is not applicable, it consists of a single concrete $\etwo$-action.

\item From state 1, the abstract $\money$-action consists of a successful concrete $\eone$, after which $\eone$ is not applicable in $P$, and hence $\etwo$ is executed instead, as specified by $\cD(\money)$. The resulting transition therefore goes to state 4, signifying that 3 euro has been inserted rather than 2.

\item From state 3, the attempt to execute the abstract $\money$-action starts with a successful concrete $\eone$, after which neither $\eone$ nor $\etwo$ are applicable. Hence the execution of $\money$ deadlocks, and due to the atomic nature of execution, no $\money$-transition exists at all.
\end{itemize}

\paragraph{Challenge.}

The challenge of this paper is to define control automata with conditional choice and action declaration. The latter takes the form of an operation $\cC[\cD]$ (for arbitrary $\cC\in \CA_A$ and $\cD:A\mapsto \CA_C$) so that $\cC[\cD]\on \cS$ is equivalent to $\cC\on (\cS\abs \cD)$ (for arbitrary $\cS\in \SA_A$).

We present our solution in the form of a \emph{control calculus} that has both conditional choice and action declaration as basic operators, as well as the familiar sequential composition and choice, and defining its operational semantics using an extended notion of control automata.
