\section{Motivation}
\label{sec:motivation}

We assume that we have a \emph{system automaton}, given as a labelled transition system (LTS), for instance generated by a set of rules that have been applied iteratively to a start object in all possible ways. The general structure of an LTS is defined as follows.

\begin{definition}[LTS]\label{defL;ts}
A \emph{Labelled Transition System} (LTS) is a tuple $\cS=\tupof{Q, L, {\trans{}}, {\final}, \qinit}$ in which
\begin{itemize}
\item $Q$ is a set of states;
\item $L$ is a set of labels, also called the \emph{alphabet} of $\cS$;
\item ${\trans{}}\subseteq Q\times\L\times Q$ is a transition relation;
\item ${\final}\subseteq Q$ is a termination predicate, identifying the subset of final states;
\item $\qinit\in Q$ is the initial state.
\end{itemize}
\end{definition}
%
The set of system automata with alphabet $L$ is denoted $\SA_A$. We will make sure that all our constructions are well-defined up to \emph{bisimilarity} of LTSs.
%
\begin{definition}[bisimilarity]\label{def:bisimilarity}
Let $Q$ be a set of states and ${\trans{}}\subseteq Q\times L\times Q$ a transition relation. Two states $q_1,q_2\in Q$ are called \emph{bisimilar} if $q_1\simeq q_2$, where ${\simeq}\subseteq Q\times Q$ is the largest symmetric relation such that
\begin{inumerate}
\item $q_1\simeq q_2\trans a q_2'$ (for arbitrary $q_1,q_2,q_2'\in Q$) implies that there is some $q_1'\in Q$ such that $q_1\trans a q_1'\simeq q_2'$;
\item $q_1\simeq q_2\final$ (for arbitrary $q_1,q_2\in Q$) implies $q_1\final$.
\end{inumerate}

Two labelled transition systems $\cS_1,\cS_2$ with disjoint state sets are called bisimilar, denoted $\cS_1\simeq \cS_2$, if $\qinit_1\simeq \qinit_2$ in $Q=Q_1\cup Q_2$ with transition relation ${\trans{}}={\rightarrow_1}\cup {\rightarrow_2}$ and termination predicate ${\final}={\final_1}\cup {\final_2}$.
\end{definition}
%
We now introduce a notion of \emph{control} over transition systems that restricts the allowed behaviour. This is achieved by \emph{imposing} a so-called \emph{control automaton} $\cC$ on a system automaton $\cS$, denoted $\cC\on \cS$. We use $\CA_L$ to denote the set of control automata with alphabet $L$; the formal definition will follow. In its simplest form, a control automaton is itself just a transition system, and imposition is exactly (TCS) synchronisation, as encoded in the following rule (where $c,c'$ are states of the control automaton in $\CA_L$ and $q,q'$ states of a system automaton $\SA_L$, for some common set of labels $L$):
%
\begin{center}
\AxiomC{$c\trans a c'$}
\AxiomC{$q \trans a q'$}
\BinaryInfC{$c\on q\trans a c'\on q'$}
\DisplayProof
%
\quad
%
\AxiomC{$c\final$}
\AxiomC{$q\final$}
\BinaryInfC{$c\on q \:\final$}
\DisplayProof
\end{center}
%
Clearly, this gives rise to another transition system (and clearly, imposition is well-defined modulo bisimilarity). We think of control transitions as \emph{enabling} or \emph{calling} an action, and system transitions as \emph{applying} of \emph{executing} them. The similarity between their formalisations will disappear as soon as we introduce more control constructs.

\paragraph{Conditional choice.}

In practice, control involves more than just restricting the allowed transitions. A feature that is found in all control languages is \emph{conditional choice}. Essentially, this means that an action is enabled only \emph{after} some other possibilities have been tried \emph{and failed because they were not applicable}. In process algebra, this construction has been studied under the name \emph{priority choice} \cite{CCS-with-priority-choice}. It involves the following extensions to the formalism:
%
\begin{itemize}
\item An auxiliary (derived) predicate ${\cando}\subseteq Q\times\powersetof{L}$ over system automata, defined by $q\cando X\iffdef \exists a\in X\st q\trans a$. In words, $q\cando X$ signifies that at least one of the actions in $X$ is applicable in $q$.

%\item An additional predicate ${\tries} \subseteq C\times \powersetof{L}$ for control automata, where $c\tries X$ signifies that $c$ enables precisely the actions in $X$;

\item Extended control labels $a\ifnot X$ (read ``$a$ unless $X$'') for $a\in L$ and $X\subseteq L$, signifying that $a$ is enabled if and only none of the actions in $X$ is applicable.
\end{itemize}
%
The rule for action execution in a controlled system then becomes:
%
\begin{center}
\AxiomC{$c\trans{a\ifnot X} c'$}
\AxiomC{$q\ncando X$}
\AxiomC{$q\trans a q'$}
\TrinaryInfC{$c\on q \trans a c'\on q'$}
\DisplayProof
\end{center}
%
\emph{Alternative} It involves an extension to control automata with a binary relation $\movesto$ over (control) states, with the intuition that $c\movesto c'$ is taken only if none of the actions called in $c$ are executable in the current state of the system automaton. This is captured by the following rules:
%
\begin{center}
\def\defaultHypSeparation{\hskip2mm}
\AxiomC{$c\on q\not\to$}
\AxiomC{$c\movesto c'$}
\AxiomC{$c'\on q\trans a c''\on q'$}
\TrinaryInfC{$c\on q \trans a c''\on q'$}
\DisplayProof
%
\quad
%
\AxiomC{$c\on q\not\to$}
\AxiomC{$c\movesto c'$}
\AxiomC{$c'\on q\:\final$}
\TrinaryInfC{$c\on q\:\final$}
\DisplayProof
\end{center}

\paragraph{Atomic abstraction.}

The second control construct we address in this paper is the ability to \emph{define} (abstract) actions as (concrete) control automata. The intuition behind this is that of procedural abstraction in programming languages: the execution of the abstract action thus defined comes down to the execution of its defining control automaton. In addition, however, we want to maintain the atomic nature of actions in our framework, meaning that we only consider the action to be executed if its defining control automaton can be applied up until a final state: a partial execution is equated to no execution at all. (In other words, such abstract actions have transactional semantics.)

In the process algebra literature, this closely corresponds to the concept of \emph{action refinement} (see \cite{Handbook-Action-Refinement} for an overview), with the difference that we are motivated by the capability to abstract, rather than refine. We will discuss the connection more closely in \Cref{sec:related}.

The abstraction itself is defined by a \emph{declaration} $\cD:A\to \CA_C$, mapping abstract actions $A$ to control automata over concrete actions $C$. We denote $A_\cD=A$ and $C_\cD=C$ for the abstract and concrete alphabets of $\cD$. The intended semantics is then captured by using $\cD$ to abstract a system automaton $\cS\in \SA_C$ to a system automaton $\cS\Uparrow \cD\in \SA_A$ with state set $\gensetof{q\Uparrow r}{q\in Q_\cS}$, as follows:

\begin{center}
\AxiomC{$c\final$}
\UnaryInfC{$c\on q\:\present\vphantom\uparrow$}
\DisplayProof
%
\quad
%
\AxiomC{$c\on q\trans a c'\on q'$}
\AxiomC{$c'\on q' \: \present$}
\BinaryInfC{$c\on q \: \present\vphantom\uparrow$}
\DisplayProof
%
\quad
%
\AxiomC{$\smash{\qinit_{\cD(a)}}\on q \trans{a} c'\on q'$}
\AxiomC{$c'\on q' \: \present$}
\BinaryInfC{$q\Uparrow \cD \trans a q'\Uparrow \cD$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\qinit_{\cD(a)}\on q \trans{}^+ c'\on q'$}
\AxiomC{$c'\final$}
\BinaryInfC{$q\Uparrow \cD \trans a q'\Uparrow \cD$}
\DisplayProof
\end{center}

\paragraph{Example.}

As running example, we define our own variation on a coffee machine. The concrete system automaton consists of two separate units: a \emph{pay unit} $P$ that accepts euro coins (denominations 1 or 2) and a \emph{dispenser unit} $B$ that dispenses coffee beans. $P$ defines actions $\eone$ and $\etwo$ for inserting 1- respectively 2-euro coins; the inserted money can be used to pay for coffee using $\emin$-actions. This pay unit has some quirks: at most two successive $\eone$s are accepted, and at most three euro can be stored at any point in time. $D$ gives out coffee beans using action $\beans$, but has to be refilled on a regular basis with action $\refill$ --- in fact, to keep the example at manageable size, we assume it has to be refilled after dispensing only a single batch of beans. We show the system automata for these two components separately; the combined behaviour is their (interleaving) parallel composition $P\times D$, with state set $\setof{0,1,2,2',3,4}\times \setof{f,e}$.

\begin{center}
\begin{tikzpicture}[baseline=(i.center),on grid]
\node (i) {};
\node (0) [below=0.7 of i] {$0$};
\node (1) [below left=of 0] {$1$};
\node (2) [below=of 1] {$2$};
\node (2') [below right=of 0] {$2'$};
\node (3) [below=of 2'] {$3$};
\node (4) [below=of 3] {$4$};

\path
  (i) edge[->] node[left=1.5] {$P:$} (0)
  (0) edge[->,bend right] node[left] {$\eone$} (1)
  (0) edge[->,bend left] node[right] {$\etwo$} (2')
  (1) edge[->] node[right] {$\emin$} (0)
  (1) edge[->,bend right] node[left] {$\eone$} (2)
  (1) edge[->] node[below] {$\etwo$} (3)
  (2) edge[->] node[right] {$\emin$} (1)
  (2) edge[->] node[below] {$\etwo$} (4)
  (2') edge[->] node[near start,above] {$\emin$} (1)
  (2') edge[->,bend left] node[right] {$\eone$} (3)
  (3) edge[->] node[left] {$\emin$} (2')
  (3) edge[->,bend left] node[right] {$\eone$} (4)
  (4) edge[->] node[left] {$\emin$} (3);
\end{tikzpicture}
\qquad
\begin{tikzpicture}[baseline=(i.center),on grid]
\node (i) {};
\node (f) [below=0.7 of i] {$f$};
\node (e) [below=1.5 of f] {$e$};

\path
  (i) edge[->] node[left=1] {$D:$} (f)
  (f) edge[->,bend right] node[left] {$\beans$} (e)
  (e) edge[->,bend right] node[right] {$\refill$} (f);
\end{tikzpicture}
\end{center}

On this system automaton, we apply atomic abstraction by declaring the following actions, using the calculus for control we formally introduce in the next section:
%
\begin{align*}
\money & \mapsto \eone;(\eone\orelse \etwo) \orelse \etwo \\
\coffee & \mapsto \emin;(\beans;\emin \orelse \refill;\beans) 
\end{align*}
%
$\money$ models the insertion of coins: the user tries to insert two 1-euro coins, but if the pay unit doesn't accept those, they insert a 2-euro coin instead. (The operator $\orelse$, read as ``or else'', introduced formally in the next section, models conditional choice: the left operand is enabled, if no initial action is applicable then the right operand is enabled instead.) $\coffee$ models obtaining a coffee: the cost is 2 euro, but if the machine is out of beans (note the occurrence of another $\orelse$) then instead the user has to refill it, paying one euro less to reward them for that service.

In fact, we define two declarations: $\cD_1$ with $A_{\cD_1}=\setof{\money,\emin}$ and $C_{\cD_1}= L_P$, consisting of the mapping for $\money$ above and the identity $\emin\mapsto \emin$, and $\cD_2$ with $A_{\cD_2}=\setof{\money,\coffee}$ and $C_{\cD_2}=L_P\cup L_D$, consisting of the mappings for $\money$ and $\coffee$ above. This gives us two cases of abstraction:

\begin{center}
\begin{tikzpicture}[on grid,baseline=(i.center)]
\node (i) {};
\node (0) [below=0.7 of i] {$0$};
\node (1) [below left=of 0] {$1$};
\node (2) [below=of 1] {$2$};
\node (2') [below right=of 0] {$2'$};
\node (3) [below=of 2'] {$3$};
\node (4) [below=of 3] {$4$};

\path (i) edge[->] node[left=1] {$P\Uparrow \cD_1:$} (0)
      (0) edge[->,bend right=60] node[left] {$\money$} (2)
      (1) edge[->] node[right] {$\emin$} (0)
      (1) edge[->] node[near start,right] {$\money$} (4)
      (2') edge[->] node[near start,above] {$\emin$} (1)
      (2') edge[->,bend left] node[right] {$\money$} (4)
      (2) edge[->] node[below] {$\money$} (4)
      (2) edge[->] node[right] {$\emin$} (1)
      (3) edge[->] node[left] {$\emin$} (2')
      (4) edge[->] node[left] {$\emin$} (3);
\end{tikzpicture}
\qquad
\begin{tikzpicture}[on grid,baseline=(i.center)]
\node (i) {};
\node (0f) [below=0.7 of i] {$0f$};
\node (2f) [below=1 of 0f] {$2f$};
\node (4f) [below=2 of 2f] {$4f$};
\node (0e) [left=3 of 0f] {$0e$};
\node (1e) [below left=of 0e] {$1e$};
\node (2e) [below=of 1e] {$2e$};
\node (2'e) [below right=1 and 1 of 0e] {$2'e$};
\node (3e) [below=of 2'e] {$3e$};
\node (4e) [below=of 3e] {$4e$};

\path (i) edge[->] node[left=3] {$(P\times D)\Uparrow \cD_2:$} (0)
      (0f) edge[->] node[right] {$\money$} (2f) 
      (2f) edge[->] node[right] {$\money$} (4f)
           edge[->] node[above] {$\coffee$} (0e)
      (4f) edge[->] node[near start,above] {$\coffee$} (2'e)
      (0e) edge[->,bend right=60] node[left] {$\money$} (2e)
      (1e) edge[->] node[right] {$\coffee$} (0e)
           edge[->] node[near start,right] {$\money$} (4e)
      (2'e) edge[->] node[near start,above] {$\coffee$} (1e)
            edge[->,bend left] node[near end,right] {$\money$} (4e)
      (2e) edge[->] node[below] {$\money$} (4e)
           edge[->] node[right] {$\coffee$} (1e)
      (3e) edge[->] node[left] {$\coffee$} (2'e)
      (4e) edge[->] node[left] {$\coffee$} (3e);
\end{tikzpicture}
\end{center}
%
We observe the following abstraction effects in $P\Uparrow \cD_1$:
%
\begin{itemize}
\item From states 0 and $2'$, the abstract $\money$-action consists of two successive concrete $\eone$-executions, whereas from state $2$, where $\eone$ is not applicable, it consists of a single concrete $\etwo$-action.

\item From state 1, the abstract $\money$-action consists of a successful concrete $\eone$, after which $\eone$ is not applicable in $P$, and hence $\etwo$ is executed instead, as specified by $\cD(\money)$. The resulting transition therefore goes to state 4, signifying that 3 euro has been inserted rather than 2.

\item From state 3, the attempt to execute the abstract $\money$-action starts with a successful concrete $\eone$, after which neither $\eone$ nor $\etwo$ are applicable. Hence the execution of $\money$ deadlocks, and due to the atomic nature of execution, no $\money$-transition exists at all.
\end{itemize}

\paragraph{Challenge.}

The challenge of this paper is to integrate atomic abstraction into control automata with priority choice. That is, for an arbitrary control automaton $\cC\in \CA_A$, system automaton $\cS\in \SA_A$ and declaration $\cD:A\mapsto \CA_C$, we want to achieve the effect of $\cC\on (\cS\Uparrow \cD)$ instead as $\cC[\cD]\on \cS$, where $\cC[\cD]\in \CA_C$ is a new control automaton constructed from $\cC$ and $\cD$. We do this by presenting a \emph{control calculus} that has both priority choice and atomic abstraction as basic operators, as well as the familiar sequential composition and choice, and defining an operational semantics using an extended notion of control automata.