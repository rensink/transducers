\section{Motivation}
\label{sec:motivation}

In this paper, we assume that we are given a \emph{system automaton}, which is labelled transition system (LTS), for instance generated by a set of rules that have been applied iteratively to a start object, in all possible ways. The general structure of an LTS is defined as follows.

\begin{definition}[LTS]\label{defL;ts}
A \emph{Labelled Transition System} (LTS) is a tuple $\cS=\tupof{Q, L, {\trans{}}, {\final}, \qinit}$ in which
\begin{itemize}
\item $Q$ is a set of states;
\item $L$ is a set of labels, also called the \emph{alphabet} of $\cS$;
\item ${\trans{}}\subseteq Q\times\L\times Q$ is a transition relation;
\item ${\final}\subseteq Q$ is a termination predicate, identifying the subset of final states;
\item $\qinit\in Q$ is the initial state.
\end{itemize}
\end{definition}
%
The set of system automata with alphabet $L$ is denoted $\SA_A$. We will make sure that all our constructions are well-defined up to \emph{bisimilarity} of LTSs.
%
\begin{definition}[bisimilarity]\label{def:bisimilarity}
Let $Q$ be a set of states and ${\trans{}}\subseteq Q\times L\times Q$ a transition relation. Two states $q_1,q_2\in Q$ are called \emph{bisimilar} if $q_1\simeq q_2$, where ${\simeq}\subseteq Q\times Q$ is the largest symmetric relation such that
\begin{inumerate}
\item $q_1\simeq q_2\trans a q_2'$ (for arbitrary $q_1,q_2,q_2'\in Q$) implies that there is some $q_1'\in Q$ such that $q_1\trans a q_1'\simeq q_2'$;
\item $q_1\simeq q_2\final$ (for arbitrary $q_1,q_2\in Q$) implies $q_1\final$.
\end{inumerate}

Two labelled transition systems $\cS_1,\cS_2$ with disjoint state sets are called bisimilar, denoted $\cS_1\simeq \cS_2$, if $\qinit_1\simeq \qinit_2$ in $Q=Q_1\cup Q_2$ with transition relation ${\trans{}}={\rightarrow_1}\cup {\rightarrow_2}$ and termination predicate ${\final}={\final_1}\cup {\final_2}$.
\end{definition}
%
We now introduce a notion of \emph{control} over transition systems that restricts the allowed behaviour. This is achieved by \emph{imposing} a so-called \emph{control automaton} on a transition system. We use $\CA_L$ to denote the set of control automata with alphabet $L$; the formal definition will follow. In its simplest form, a control automaton is itself just a transition system, and imposition is exactly (TCS) synchronisation, as encoded in the following rule (where $c,c'$ are states of the control automaton in $\CA_L$ and $q,q'$ states of a system automaton $\SA_L$, for some common set of labels $L$):
%
\begin{center}
\AxiomC{$c\trans a c'$}
\AxiomC{$q \trans a q'$}
\BinaryInfC{$c\on q\trans a c'\on q'$}
\DisplayProof
%
\quad
%
\AxiomC{$c\final$}
\AxiomC{$q\final$}
\BinaryInfC{$c\on q \:\final$}
\DisplayProof
\end{center}
%
Clearly, this gives rise to another transition system (and clearly, imposition is well-defined modulo bisimilarity). We think of control transitions as \emph{enabling} an action, and system transitions as \emph{applying} them. The similarity between their formalisations will disappear as soon as we introduce more control constructs.

\paragraph{Conditional choice.}

In practice, control involves more than just restricting the allowed transitions. A feature that is found in all control languages is \emph{conditional choice}. Essentially, this means that an action is enabled only \emph{after} some other possibilities have been tried \emph{and failed because they were not applicable}. In process algebra, this construction has been studied under the name \emph{priority choice} \cite{CCS-with-priority-choice}. It involves the following extensions to the formalism:
%
\begin{itemize}
\item An auxiliary (derived) predicate ${\cando}\subseteq Q\times\powersetof{L}$ over system automata, defined by $q\cando X\iffdef \exists a\in X\st q\trans a$. In words, $q\cando X$ signifies that at least one of the actions in $X$ is applicable in $q$.

%\item An additional predicate ${\tries} \subseteq C\times \powersetof{L}$ for control automata, where $c\tries X$ signifies that $c$ enables precisely the actions in $X$;

\item Extended control labels $a\ifnot X$ (read ``$a$ unless $X$'') for $a\in L$ and $X\subseteq L$, signifying that $a$ is enabled if and only none of the actions in $X$ is applicable.
\end{itemize}
%
The rule for action execution in a controlled system then becomes:
%
\begin{center}
\AxiomC{$c\trans{a\ifnot X} c'$}
\AxiomC{$q\ncando X$}
\AxiomC{$q\trans a q'$}
\TrinaryInfC{$c\on q \trans a c'\on q'$}
\DisplayProof
\end{center}

\paragraph{Atomic abstraction.}

The second control construct we address in this paper is the ability to \emph{define} (abstract) actions as (concrete) control automata. The intuition behind this is that of procedural abstraction in programming languages: the execution of the abstract action thus defined comes down to the execution of its defining control automaton. In addition, however, we want to maintain the atomic nature of actions in our framework, meaning that we only consider the action to be executed if its defining control automaton can be applied up until a final state: a partial execution is equated to no execution at all. (In other words, such abstract actions have transactional semantics.)

In the process algebra literature, this closely corresponds to the concept of \emph{action refinement} (see \cite{Handbook-Action-Refinement} for an overview), with the difference that we are motivated by the capability to abstract, rather than refine. We will discuss the connection more closely in \Cref{sec:related}.

The abstraction itself is defined by a function $r:A\to \CA_C$, mapping abstract actions $A$ to control automata over concrete actions $C$. The intended semantics is then captured by using $r$ to abstract a system automaton $\cS\in \SA_C$ to a system automaton $\cS\Uparrow r\in \SA_A$ with state set $\gensetof{q\Uparrow r}{q\in Q_\cS}$, as follows:

\begin{center}
\AxiomC{$c\final$}
\UnaryInfC{$c\on q\:\present\vphantom\uparrow$}
\DisplayProof
%
\quad
%
\AxiomC{$c\on q\trans a c'\on q'$}
\AxiomC{$c'\on q' \: \present$}
\BinaryInfC{$c\on q \: \present\vphantom\uparrow$}
\DisplayProof
%
\quad
%
\AxiomC{$\smash{\qinit_{r(a)}}\on q \trans{a} c'\on q'$}
\AxiomC{$c'\on q' \: \present$}
\BinaryInfC{$q\Uparrow r \trans a q'\Uparrow r$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\qinit_{r(a)}\on q \trans{}^+ c'\on q'$}
\AxiomC{$c'\final$}
\BinaryInfC{$q\Uparrow r \trans a q'\Uparrow r$}
\DisplayProof
\end{center}

\paragraph{Example.}

As running example, we define our own variation on a coffee machine. The concrete system automaton consists of two separate units, one of which accepts euro coins (denominations 1 or 2) using actions $\eone$ and $\etwo$; the inserted money can be used to pay for coffee using $\emin$-actions. This pay unit has some quirks: at most two successive $\eone$s are accepted, and at most three euro can be stored at any point in time. The second unit dispenses coffee beans using action $\beans$, but has to be refilled on a regular basis with action $\refill$ --- in fact, to keep the example at manageable size, it has to be refilled after dispensing only a single batch of beans. We show the system automata for these two components separately; the combined behaviour is their (interleaving) parallel composition.

\begin{tikzpicture}[on grid]
\node (0) {$0$};
\node (1) [below left=of 0] {$1$};
\node (2) [below=of 1] {$2$};
\node (2') [below right=of 0] {$2'$};
\node (3) [below=of 2'] {$2$};
\end{tikzpicture}

On this system automaton, we apply atomic abstraction by defining two the following actions:
%
\begin{align*}
\money & \mapsto \eone;(\eone\orelse \etwo) \orelse \etwo \\
\coffee & \mapsto \emin;(\beans;\emin \orelse \refill;\beans) 
\end{align*}
%
$\money$ models the insertion of coins: the user tries to insert two 1-euro coins, but if the pay unit doesn't accept those, they insert a 2-euro coin instead. (The operator $\orelse$, read as ``or else'', introduced formally in the next section, models conditional choice: the left operand is enabled, if no initial action is applicable then the right operand is enabled instead.) $\coffee$ models obtaining a coffee: the cost is 2 euro, but if the machine is out of beans (note the occurrence of another $\orelse$) then instead the user has to refill it, paying one euro less to reward them for that service.